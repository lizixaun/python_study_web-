#走迷宫，但不是最短路线（使用栈）---深度优先遍历（就是一条路先走到黑，然后再一步步回来）
#想要走最短，需要使用队列（队列就是先进先出，排队银行取💴，谁先来先取💴）思路：按圈进入队列的，哪个圈先到，结果就是哪条路进，这个叫广度优先遍历
#创建迷宫
#“迷宫”或“迷魂阵
maze=[
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 1, 1, 0, 0, 0, 1, 1, 1],
    [1, 0, 1, 1, 1, 1, 0, 0, 1, 1],
    [1, 0, 1, 0, 0, 0, 0, 0, 1, 1],
    [1, 0, 1, 0, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 1, 1, 1, 1, 1, 1],
    [1, 1, 1, 0, 0, 0, 0, 1, 1, 1],
    [1, 1, 1, 0, 0, 1, 0, 1, 1, 1],
    [1, 1, 1, 1, 1, 1, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
]
#设置起点
#设置终点
start=(1,1)
end=(8,8)
#判断当前这个点，上下左右是0，还是1，如果是0可以走，
#下面这个点：r+1,c(行号加1，列不变)-------行:rows，列:columns。
#右边：r,c+1
#左边：r,c-1
#上：r-1,c
#需要一个容器，记录我们走过的路，一旦走到底了，就返回上一个分叉路口
lst=[start]      #列表中放的是我每一步走的坐标     （r,c）,先放进去的也就是起始位置
while lst:
    #列表有东西才能继续向下走
    #当前走到的节点是哪一个(也就是列表最后一个节点)
    now=lst[-1]
    if now ==end:
        print("出来了")
        print(lst)#打印出一共走了，哪些路
        break
    row,col=now #解包（2，1）#放相应个数的参数就可以解包
    #走过的不能再走，不然就死循环了。解决方法：走过的设为其他数字
    maze[row][col]=2 #这个点已经走过了，标记一下"""Python 中对二维列表（也就是包含列表的列表）进行索引和赋值的方式。maze[row][col] 表示在 maze 这个二维列表中，首先按照行索引 row 定位到某一行，然后在该行中按照列索引 col 定位到某一个具体的元素位置。"""
    #上右下左，邻居是不是0，是0就可以走
    if maze[row-1][col]==0:
        #上方可以走
        lst.append((row-1,col))#一整个丢进去
        continue
    elif maze[row][col+1]==0:
        # 右方可以走
        lst.append((row , col+1))
        continue
    elif maze[row+1][col]==0:
        # 下方可以走
        lst.append((row + 1, col))
        continue

    elif maze[row][col-1]==0:
        # 上方可以走
        lst.append((row , col-1))
        continue
    else:
        lst.pop()#把最后一个节点踢出去
else:
    print("迷宫走不通")
"""#也就是栈：特点：先进后出
#list就是一个栈
lst=[]
lst.append("1")#append在python里面是在屁股后面添加
lst.append("2")
lst.append("3")
lst.append("4")
#lst[1,2,3,4]
print(lst.pop())#pop弹出去（弹出最后一个）--4
print(lst.pop())#-----------------------3"""